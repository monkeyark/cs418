<html>
<head>
<title>Programming Project: Trapezoidal Maps and Point Queries</title> 
<link rel="stylesheet" href="../homepage.css" type="text/css">
</head>

<body bgcolor="white" vlink="red"> 

<center>
<h2>Programming Project: Trapezoidal Maps and Point Queries </h2>

</center>

In this programming project, you are asked to implement the randomized algorithm for 
incremental construction of a trapezoidal map and its associated point query 
algorithm as described in Chapter 6.  
The input will be a planar subdivision represented as a doubly 
connected edge list (DCEL).  Your code first permuates the edges randomly and then 
adds them according to the <i>order in the permutation</i>.  
You may use the procedure for random permutation on page 77.  
</font>

<p>


The generated trapezoid map <i>T</i> is not explicitly represented.  Its structure can be 
recovered from the trapezoid records. Every trapezoid <tt>t</tt> stores 
four pointers/references describing its geometry: 
<ul>
<li> <tt>top</tt> for the top bounding edge (from the input DCEL); 
<li> <tt>bottom</tt> for the bottom bounding edge (also from the input DCEL); 
<li> <tt>leftp</tt> defining the trapezoid's left vertical edge (possibly degenerating
to the point <tt>leftp</tt>); and 
<li> <tt>rightp</tt> defining its right vertical edge (possibly degenerating to 
the point <tt>rightp</tt>). 
</ul> 
 
 
The search structure <i>D</i> is represented by a directed acyclic graph (DAG).  
The trapezoids and 
the leaves in <i>D</i> should cross reference each other.


<h3> Convention on Naming</h3> 

You are allowed to use any programming language in the implementation.
The output "name" of a geometric or graph entity (e.g., a vertex, an edge, etc.) should follow the 
convention below. In the case, say, an object-oriented programming language such as Java is used, 
this name refers to the printed name of the object of some class representing the geometric entity 
as generated by the class' <tt>toString()</tt> method, not the name of a referrence variable for 
the same object. 

<ul> 

<li> The left, right, top, and bottom sides of the bounding box <i>R</i> for the
planar subdivision are named 
<tt>L</tt>, <tt>R</tt>, 
<tt>T</tt>, and <tt>B</tt>, respectively. 

<li> The four vertices of <i>R</i>, starting at the upper left corner, are named 
counterclockwise as <tt>c1</tt>, <tt>c2</tt>, <tt>c3</tt>, and <tt>c4</tt>. 

<li> A trapezoid, whether degenerating into a triangle or not, has its name starting with <tt>t</tt> and ending 
with a unique number, for example, <tt>t10</tt>.

<li> Every vertex in the input planar division (and the non-explicitly represented  trapezoidal map)
 has its name starting with <tt>v</tt> and ending with a unique number, 
for instance, <tt>v4</tt>.

<li> A half-edge, say, from the vertex </tt>v4</tt> to the vertex <tt>v5</tt>, should be named 
<tt>e4,5</tt>; hence its twin half-edge is named <tt>e5,4</tt>.  

<li> In the search structure <i>D</i> (a DAG), it is suggested that 
you create three subclasses of the <tt>Node</tt> class: one for <i>x</i>-nodes, one for <i>y</i>-nodes, and 
one for leaves.  An <i>x</i>-node is named after the corresponding vertex; 
a <i>y</i>-node is named after the corresponding edge; and a leaf is named after the
corresponding trapezoid. It is possible that multiple nodes in <i>D</i> have the same (printed) name. 
 
   
</ul> 



<h3> Doubly Connected Edge List</h3>

Recall from the textbook (pp. 29-33) that a DCEL includes three types of
records.  Consider a planar subdivision induced by three segments that happen to be the 
sides of a triangle 
with vertices v1 = (0, 0), v2 = (1, 0), and v3 =
(0, 1).  Let f1 be the face bounded by the triangle and f2 be the
unbounded face.  The following is a valid DCEL representation
of this subdivision.

<p> 

<tt>
v1  (0, 0)  e1,2<br>
v2  (1, 0)  e2,3<br>
v3  (0, 1)  e3,1<br><br>

f1  e2,3  nil <br>
f2  nil  e1,3 <br><br>

e1,2  v1  e2,1  f1  e2,3  e3,1<br>
e2,1  v2  e1,2  f2  e1,3  e3,2<br>
e1,3  v1  e3,1  f2  e3,2  e2,1<br>
e3,1  v3  e1,3  f1  e1,2  e2,3<br>
e2,3  v2  e3,2  f1  e3,1  e1,2<br>
e3,2  v3  e2,3  f2  e2,1  e1,3<br><br>
</tt> 

Always leave <i>two</i> blank spaces between adjacent names on each
line, and <i>one</i> blank line between records of different types. 
If a face has multiple holes, then its record should list a sequence of half-edges separated by 
semicolons, one from the boundary of each hole.  For example,  the following is a record 
of some unbounded face <tt>f1</tt>:
<p> 
<tt> 
f1 nil e9,10;e1,2;e13,11
</tt> 
<p> 

The face has three inner components, i.e, the planar subdivision has three connected components 
(at the outmost level as they may contain holes themselves).  These components respectively 
have half-edges <tt>e9,10</tt>, <tt>e1,2</tt>, and <tt>e13,11</tt> on their boundaries.
<p> 


<h3>Input</h3> 

In practice, point location usually takes place on a map.  Therefore, 
an input file stores a DCEL representing some planar subdivision, which at the moment is not 
enclosed in a bounding box. 
 

<h3>Trapezoidal Map Construction and Query</h3> 

You are asked to implement the randomized incremental algorithm described in Section 6.2 for constructing 
the trapezoidal map and its associated search structure from an input file.   
Your code should handle the following two degeneracies (see  
Section 6.3 of the textbook): 
<ul> 
<li> Two or more endpoints (possbily on the same edge) have the same <i>x</i>-coordinate.
<li> A query point is on the vertical line of an <i>x</i>-node.
</ul> 

Your code should be able to perform a query with a point and output the trapezoid 
containing the point as specified next. 


<h3>Output</h3>

Your code will read from a file <i>name</i><tt>.txt</tt> (<i>name</i> being a string of digits, 
English letters, and dash) and output in the file <tt>trapezoidalMap.txt</tt> as below. 

 


Every trapezoid is output as a sequence that 
starts with two segments <tt>top</tt> and <tt>bottom</tt> and end with two vertices <tt>leftp</tt> and <tt>rightp</tt>. 
<ul>
<li> The four objects <tt>top</tt>, <tt>bottom</tt>, <tt>leftp</tt>, and <tt>rightp</tt> are output on separate lines. 
<li> <tt>leftp</tt> and <tt>rightp</tt> are output as their names in the DCEL, for example, <tt>v1</tt> and
<tt>v2</tt>.
<li> <tt>top</tt> and <tt>bottom</tt> are each output as the name of the corresponding half-edge
that bounds the trapezoid. 
<!--
<li> The left endpoint of a non-vertical segment <i>precedes</i> its right endpoint.  
<li> The lower endpoint of a vertical segment <i>precedes</i> its upper endpoint. 
--> 
<li> If the trapezoid is bounded on the left (the right, respectively) by a vertical edge from the input
planar subdivision, let <tt>leftp</tt> (<tt>rightp</tt>, respectively) denote the lower endpoint of that edge.  
<li> The left, right, top, and bottom edges of the bounding box are written as the letters "<tt>L</tt>", 
"<tt>R</tt>", "<tt>T</tt>", and "<tt>B</tt>", 
respectively.  
</ul>
<p> 

Below is a sample output for the (degenerate) trapezoid representing the triangle given 
earlier with vertices <tt>v1</tt>, <tt>v2</tt>, and <tt>v3</tt>.
<br><br> 

<tt>

e2,3<br>
e1,2<br>
v1<br>
v2 <br><br>

</tt>

In outputing a trapezoidal map, list all trapezoids contained inside one face from the input
planar subdivision before moving on to another face.  No particular order is assumed among
the faces, or among the trapezoids inside the same face. You have the freedom to choose an order for
traversing the faces, as well as an order for traversing the trapezoids inside the same face.  Output the name 
of a face, followed by a listing of its contained trapezoids, then the name of the next face, 
and so on. Below is a sample output of the trapezoidal map constructed over the earlier DCEL example defined
by a single triangle: 

<p> <br>

<tt>
****** Trapezoidal Map******<br> 

<br>

Face f1 contains 1 trapezoid: <br><br>

e2,3<br>
e1,2<br>
v1<br>
v2 <br><br><br>

Face f2 contains 4 trapezoids: <br><br>

T<br>
B<br>
L<br>
v1 <br><br>

T<br>
e3,2<br>
v3<br>
v2<br><br>

T<br>
B<br>
v2<br>
R<br><br> 

e2,1<br>
B<br>
v1<br>
v2<br><br>


</tt>


<p> 
A query point may coincide with a vertex.  It may also lie in the interior of an input edge, a later 
created vertical edge, or a trapezoid. 
<ul> 
<li> If the query point is a vertex in the input planar subdivision, just output the vertex name, e.g., <tt>
v2</tt>.   
<li> If the point is not a vertex but lies on an edge in the planar subdivsion, just output one of
the two corresponding half-edges, 
e.g., <tt>e1,3</tt>. 
<li> If the point lies on a created vertical edge of the trapezoidal map, output either of the two trapezoids 
sharing the edge according to the output format for a trapezoid given earlier.  
<li> If the point is in the interior of a trapezoid, then output the trapezoid in the given format. 
</ul>
Testing the incidence of a point on an edge or the coincidence of two points comes down to checking whether 
certain expression is equal to zero.  
Due to floating arithmetics, a number is considered to be "zero" if it is less than some very small constant 
<tt>epsilon</tt>.  You may set its value to, say, <tt>0.000001</tt>, although the actual value also depends on how 
you set up the expression, e.g., normalizing a vector or not. 

<p> 
 
During the user interaction, the constructed trapezoidal map for every input planar subdivision is stored in a 
separate file named by yourself.  Below is a sample execution scenario, during which a
 lower case x ends a query or the entire execution. 

<p>
<tt>
Point Location Using Trapezoidal Maps<br><br>

Trial 1: <br>
Name of the input planar subdivision file: <b>subdivision1.txt</b> <br>
Trapezoidal map constructed in the file <b>trapezpoidalMap1.txt</b><br><br>


Query point: <b>(1, 1)</b><br>
Trapezoid containing the point (1, 1): <br>
... <br><br>

Query point: <b>(0, 0)</b><br> 
Vertex of the input subdivision:<br>
v1 (0, 0) e1,2<br><br>

Query point: <b>(0.5,0.5)</b><br>
On an edge of the input subdivision:<br>
e2,3 v2 e3,2 f1 e3,1 e1,2<br><br>


Query point: <b>(4, 3)</b><br>
Trapezoid containing the point (4, 3): <br>
... <br><br>

Query point: <b>x</b><br>
End of all queries in this map. <br><br><br>


Trial 2: <br>
Name of the input planar subdivision file: <b>subdivision2.txt</b> <br>
Trapezoidal map constructed in the file <b>trapezoidalMap2.txt</b><br><br>

Query point: <b>(-3, 10)</b><br>
Trapezoid containing the point (-3, 10): <br>
... <br><br>

Query point: <b>x</b> <br>
End of all queries in this map.<br><br><br>

Trial 3:<br>
Name of the input planar subdivision file: <b>x</b>  <br><br><br>

End of execution <br><br>

</tt>
<p>
<p>

Your code should print out the same text messages for user interactions. 


<h3>Graphics (for bonus points)</h3>

You may receive up to 30 bonus points for graphical display of the constructed
trapezoidal map alone, or together with the search structure DAG.  


<!--
In writing discuss the issues encountered in your implementation.
There is no need to reiterate Fortune's plane sweep algorithm in
detail.  For instance, you may explain how to maintain the DCEL during
the plane sweep to construct the Voronoi diagram, how to handle the
degeneracies, and how to generate the Delaunay Triangulation in a DCEL
representation, etc.  

<p> 
--> 



</body>
